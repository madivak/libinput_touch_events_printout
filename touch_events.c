/*
 * Author : Kevin Amadiva <madivak@live.co.uk>
 */ 

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/input.h>
#include <stdbool.h>
#include <math.h>

//#define EVENT_DEVICE      "/dev/input/event1"
#define EVENT_EV_ABS      EV_ABS
#define EVENT_EV_SYN      EV_SYN
#define EVENT_CODE_X      ABS_MT_POSITION_X
#define EVENT_CODE_Y      ABS_MT_POSITION_Y
#define SLOT_0             0
#define SLOT_1             1
#define SLOT_2             2
#define SLOT_3             3
#define SLOT_4             4
#define RELEASE           -1

void process_data(__s32 x, __s32 y, uint *arr);

/* TODO: Close fd on SIGINT (Ctrl-C), if it's open */

int main(int argc, char *argv[])
{
    struct input_event ev;
    int fd;
    char name[256] = "Unknown";
    __s32 xvalue = 0, yvalue = 0;
    bool dump = false, MT = false;
    bool dumpstats = false;

    //Check if user passed the device string variable.
    if (argc != 2) {
      printf("Include the device to read from\n\n");
      printf("Usage example:\n\n");
      printf("./%s /dev/input/event0\n\n", argv[0]);
      return 1;
    }

    if ((getuid()) != 0) {
        fprintf(stderr, "You are not root! This may not work...\n");
        return EXIT_SUCCESS;
    }

    /* Open Device */
    fd = open(argv[1], O_RDONLY);
    if (fd == -1) {
        fprintf(stderr, "%s is not a vaild device\n", argv[1]);
        return EXIT_FAILURE;
    }

    /* Print Device Name */
    ioctl(fd, EVIOCGNAME(sizeof(name)), name);
    printf("Reading from:\n");
    printf("device file = %s\n", argv[1]);
    printf("device name = %s\n", name);

    uint xstats[] ={0,0,0,0,0,0,0,0,0,0,0};
    uint ystats[] ={0,0,0,0,0,0,0,0,0,0,0};
    u_int16_t SLOT0[]={0,0};
    u_int16_t SLOT1[]={0,0};
    u_int16_t SLOT2[]={0,0};
    u_int16_t SLOT3[]={0,0};
    u_int16_t SLOT4[]={0,0};
    int SLOT = 0;


    for (;;) {
        const size_t ev_size = sizeof(struct input_event);
        ssize_t size;

        /* TODO: use select() */

        size = read(fd, &ev, ev_size);
        if (size < ev_size) {
            fprintf(stderr, "Error size when reading\n");
            goto err;
        }
        //For type B device (type A are stateless) -> ABS_MT_SLOT [touch generated by touch agent 0 always for 1 finger.]
        //Track ABS_MT_TRACKING_ID for when event ends

        //If EV_ABS types, TrackingID should be
        if (ev.type == EVENT_EV_ABS ) {

            //X and Y coodinates
            if (ev.code == EVENT_CODE_X || ev.code == EVENT_CODE_Y) {
                // printf("%s = %d\n", ev.code == EVENT_CODE_X ? "X" : "Y",
                //         ev.value);
                switch (ev.code)
                {
                  case EVENT_CODE_X:
                    process_data(xvalue, ev.value, xstats);
                    xvalue = ev.value;
                    break;

                  case EVENT_CODE_Y:
                    process_data(yvalue, ev.value, ystats);
                    yvalue = ev.value;
                }
            }

            //Detect number of Multitouch
            if (ev.code == ABS_MT_SLOT) { //} && ev.value != ZERO) {

              switch (SLOT)
              {
                case 0:
                      SLOT0[0]=(u_int16_t) xvalue;
                      SLOT0[1]=(u_int16_t) yvalue;
                case 1:
                      SLOT1[0]=(u_int16_t) xvalue;
                      SLOT1[1]=(u_int16_t) yvalue;
                case 2:
                      SLOT2[0]=(u_int16_t) xvalue;
                      SLOT2[1]=(u_int16_t) yvalue;
                case 3:
                      SLOT3[0]=(u_int16_t) xvalue;
                      SLOT3[1]=(u_int16_t) yvalue;
                case 4:
                      SLOT4[0]=(u_int16_t) xvalue;
                      SLOT4[1]=(u_int16_t) yvalue;
              }
                //printf("----------MULTITOUCH DETECTED----------\n");
                //dump = true;

              if (ev.value == SLOT_0) {
                SLOT = SLOT_0;
                xvalue = (__s32) SLOT0[0];
                yvalue = (__s32) SLOT0[1];

              } else if (ev.value == SLOT_1) {
                SLOT = SLOT_1;
                xvalue = (__s32) SLOT1[0];
                yvalue = (__s32) SLOT1[1];

              } else if (ev.value == SLOT_2) {
                SLOT = SLOT_2;
                xvalue = (__s32) SLOT2[0];
                yvalue = (__s32) SLOT2[1];

              } else if (ev.value == SLOT_3) {
                SLOT = SLOT_3;
                xvalue = (__s32) SLOT3[0];
                yvalue = (__s32) SLOT3[1];

              } else if (ev.value == SLOT_4) {
                SLOT = SLOT_4;
                xvalue = (__s32) SLOT4[0];
                yvalue = (__s32) SLOT4[1];

              }
                //SLOT = (int ev.value);
                MT = true;
            }

            //Detect end of a tracking event
            if (ev.code == ABS_MT_TRACKING_ID && ev.value == RELEASE) {
                dumpstats = true;
            }
        }

        else if (ev.type == EVENT_EV_SYN ) {
            //printf("SYNC event\n");
            if (ev.code == SYN_DROPPED) {
                printf("----------SYN_DROPPED----------\n");
            }

            dump = true; //(ev.code == SYN_MT_REPORT || SYN_REPORT )
        }

        if ( dump || MT ) {
            printf("Time: %ld.%06ld:  ", ev.input_event_sec, ev.input_event_usec);
            printf("%d : %d\n", xvalue, yvalue);
            //printf("Event: %d\n", ev.code);
            dump = false;

            if ( MT ) {
              printf("----------MULTITOUCH DETECTED----------\n");
              MT = false;
            }

            if (dumpstats) {
                  printf("----------FINGER LIFTED----------\n");
                  printf("X-Axis:|%d|%d|%d|%d|%d|%d|%d|%d|%d|%d|%d|\n", xstats[0], xstats[1] , xstats[2], xstats[3], xstats[4], xstats[5], xstats[6], xstats[7], xstats[8], xstats[9], xstats[10]);
                  printf("Y-Axis:|%d|%d|%d|%d|%d|%d|%d|%d|%d|%d|%d|\n", ystats[0], ystats[1], ystats[2], ystats[3], ystats[4], ystats[5], ystats[6], ystats[7], ystats[8], ystats[9], ystats[10]);
                  dumpstats = false;
            }
        }


    }

    return EXIT_SUCCESS;

err:
    close(fd);
    return EXIT_FAILURE;
}

void process_data(__s32 x, __s32 y, uint *arr)
{
  __s32  res = x - y;

  uint w = abs(res);
  if (res < 0) {
    arr[10]++;
  }

  if (w > 8) {
    arr[9]++;

  } else {
    arr[w]++;
  }
}